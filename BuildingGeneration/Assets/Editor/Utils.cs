using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Utils {

    public static System.Random rng = new System.Random();

    // --------- Math Helpers ---------

    /// <summary>
    /// Given a discrete CDF this selects a weighted random 
    /// index in that cdf (larger jumps in value are more 
    /// likely to be selected).
    /// </summary>
    /// <param name="cdf">
    /// The cumulative distribution function as an array.
    /// Should be generated by Utils.CalcCDF.
    /// This must be an array of doubles on the range (0.0, 1.0], 
    /// in increasing order where the last element must be 1.0.
    /// </param>
    /// <returns></returns>
    /// <example>
    /// WeightedRandomIndex([0.1, 1.0]) is 9x (0.9/0.1) more 
    /// likely to return index 1 rather than index 0.
    /// </example>
    public static int WeightedRandomIndex(double[] cdf)
    {
        double val = rng.NextDouble();
        int low = 0;
        int high = cdf.Length - 1;

        for (int i = 0; i < cdf.Length; i++)
        {
            int mid = (low + high) / 2;
            if (cdf[mid] < val)
            {
                low = mid;
            }
            else
            {
                high = mid;
            }
            if (low == high - 1)
            {
                break;
            }
        }
        return high;
    }

    /// <summary>
    /// Turns a set of ordered values into a discrete CDF.
    /// </summary>
    /// <param name="values">The ordered values</param>
    /// <returns>
    /// The discrete CDF of the same length as values. 
    /// The last and highest value will be 1.0
    /// </returns>
    /// <example>
    /// CalcCDF([1, 3, 6]) == [1/10, (1+3)/10, (1+3+6)/10] == [0.1, 0.4, 1.0]
    /// </example>
    /// <remarks>
    /// If all values are zero this returns the cdf of a uniform distribution.
    /// </remarks>
    public static double[] CalcCDF(int[] values)
    {
        double[] cdf = new double[values.Length];
        int total_points = 0;

        for (int i = 0; i < values.Length; i++)
        {
            total_points += values[i];
        }

        if (total_points == 0)
        {
            // If there are no values then return a uniform distribution cdf.
            for (int i = 0; i < values.Length; i++)
            {
                cdf[i] = 1.0 / values.Length * (i + 1);
            }
        }
        else
        {
            double cumulative_points = 0.0;
            for (int i = 0; i < cdf.Length; i++)
            {
                cdf[i] = (((double)values[i]) / total_points) + cumulative_points;
                cumulative_points = cdf[i];
            }
        }
        return cdf;
    }
}
